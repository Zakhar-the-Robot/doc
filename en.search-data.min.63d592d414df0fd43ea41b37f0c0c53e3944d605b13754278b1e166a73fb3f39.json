[{"id":0,"href":"/doc/docs/communication-protocols/canbus/","title":"Canbus","section":"Communication Protocols","content":"ZakharCAN (ver. 0.0.0) #  The standard is based on the CAN bus protocol. Base CAN configuration:\n Bitrate: 125 kbits/s ID: 11 bits  In the standard there are several common parameters:\n Common timeout: 3 sec Dev ID size: 3 bits Data ID size: 4 bits  Addressing #  Each device uses 3 highest bits of the 11-bit ID for it\u0026rsquo;s ID (0..7). The last 4 bits are used for different data types (0..15). Bits from 5 to 8 are reserved for future use.\n1 2 3   0b X X X X X X X X X X X  |-------|---------|---------|  Address Reserved Data ID   Example of the device id 0x104:\n Device Address: 0x1 Data ID: 0x4  Standard Versioning #  Note: Until version 1.0.0 this section can be violated\nThe version consists of 3 numbers: Major.Minor.Patch (e.g. 2.3.9)\n All devices using the same Major should be able to interact with each other All devices using the same Minor should be able to interact with each other and have to have the same feature set  Internal Error Codes #     Code Name     0x0 OK   0x1 TIMEOUT_ERROR   0xFF GENERAL_ERROR    Data Types #     Data ID Name Description     0x0 DeviceInfo Used for presence declaration each Common timeout (see details bellow). In response for the request should return a data frame with DATA[0]:Major, DATA[1]:Minor, DATA[2]:Patch   0x1  Reserved for future   0x2\u0026hellip;0x15 DeviceData Device specific data defined by each device.    Operations #  Send data #   Send a CAN frame:  Identifier: (DevID \u0026lt;\u0026lt; 8) | DataID RTR: 0x0 Data length code (DLC): 0x0..0x8 Data: 0\u0026hellip;8 bytes    Request data #    Send a CAN frame:\n Identifier: (DevID \u0026lt;\u0026lt; 8) | DataID (ID of the requested data!) RTR: 0x1 Data length code (DLC): 0x0 Data: 0 bytes    Wait for a message with the requested ID during the Common timeout\n  If the message has come: OK, overwise: TIMEOUT_ERROR\n  Declare the Presence #  A device is online if it declares its presence on the line each Common timeout.\nTo declare being online the device should:\n Send a CAN frame:  Identifier: DevID \u0026lt;\u0026lt; 8 (0xN00) RTR: 0x0 Data length code (DLC): 0x0 Data: 0 bytes    Compatible libraries #  Libraries bellow are developed inside the Zakhar project and support ZakharCAN.\n Arduino: https://github.com/an-dr/zklib_arduino_canbus ESP-IDF: https://github.com/an-dr/zklib_espidf_canbus STM32: https://github.com/an-dr/zklib_stm32_canbus  "},{"id":1,"href":"/doc/docs/communication-protocols/i2c-deprecated/","title":"I2c ( Deprecated)","section":"Communication Protocols","content":"This file describes I2C communication used by Zakhar\u0026rsquo;s systems\nBasic description #   Standard uses 7-bit addressing. Devices can have data located in 0x02\u0026hellip;0xFE registers - 253 bytes Each device mandatorily has registers 0x00 to store command, 0x01 for arguments, and 0x02 to store device state. Commands should be represented by values 0x01\u0026hellip;0xFE Read and write operations are described bellow  Registers #  Minimal register map:\n REG_CMD - Command register. The device is reading commands from here REG_ARG - Optional argument of the command REG_MODE - Mode register. If device support working in several modes, this register should be used to indicate it. other addresses can be used for device specific data  Read/Write operations #  To read master should consequently:\n Send Start state Send Write command Send Register number Send Start state Send Read command Read byte(s) Send NACK Send Stop state  Then read one byte - the value from the register\nTo write data master should consequently:\n Send Start state Send Write command Send Register number Send Data byte(s) Send Stop state  Command writing process #  Full process #   A) Master read the REG_CMD register. If it is not 0x00 - slave should be considered as busy. B) If slave is not busy Master writes 0xFF to REG_CMD C) Optionally write argument to REG_ARG D) Master writes a command to the REG_CMD (command is any value in the range 0x01\u0026hellip;0xFE) E) When the command is executed, slave sets CMD and ARG registers to 0x00  Simplified process #   A) (optionally) Write an argument to REG_ARG B) Write a command to REG_CMD  "},{"id":2,"href":"/doc/docs/systems/brain/ros_install/","title":"Ros Install","section":"Brain","content":"ROS instalation #  At the time of summer 2020 there is no way to install noetic on Raspberry Pi OS. That\u0026rsquo;s why we will build it manually\nROS Noetic build #  Step 1 — Set up ROS Noetic repo on Raspberry Pi 4 #  1  sudo sh -c \u0026#39;echo \u0026#34;deb http://packages.ros.org/ros/ubuntu buster main\u0026#34; \u0026gt; /etc/apt/sources.list.d/ros-noetic.list\u0026#39;   Step 2 — Add official ROS key #  1  sudo apt-key adv --keyserver \u0026#39;hkp://keyserver.ubuntu.com:80\u0026#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654   Step 3 — Pull all meta info of ROS Noetic packages #  1  sudo apt update   Step 4 — Install build dependencies on Raspberry Pi 4 #  1  sudo apt-get install -y python-rosdep python-rosinstall-generator python-wstool python-rosinstall build-essential cmake   Step 5 — Set up ROS Noetic dependency sources/repos #  1 2  sudo rosdep init rosdep update   Step 6 — Fetch \u0026amp; Install ROS Noetic dependencies #  1 2 3 4 5  mkdir ~/ros_catkin_ws cd ~/ros_catkin_ws rosinstall_generator ros_comm --rosdistro noetic --deps --wet-only --tar \u0026gt; noetic-ros_comm-wet.rosinstall wstool init src noetic-ros_comm-wet.rosinstall rosdep install -y --from-paths src --ignore-src --rosdistro noetic -r --os=debian:buster   Step 7 — Compiling Noetic packages on Raspberry Pi 4 #  1  sudo src/catkin/bin/catkin_make_isolated --install -DCMAKE_BUILD_TYPE=Release --install-space /opt/ros/noetic -j1 -DPYTHON_EXECUTABLE=/usr/bin/python3   Done! #  As a source of this manual was used an article:\nHow to Install ROS Noetic on Raspberry Pi 4 - VarHowto\n"},{"id":3,"href":"/doc/for_developers/","title":"For Developers","section":"Main","content":"For Developers #    \nThe project is ambitious, and I cannot move it that fast as I want to. If you are as interested in robotics as I am, let\u0026rsquo;s try to work together. I\u0026rsquo;m confident that we will develop something unique.\nThe project covers many different areas and programming languages, including:\n 3D modeling (for simulation) 3D printing (for the robot itself) C / C ++ development (embedded: Arduino, ESP32, STM32; hi-level: Linux, Robot Operating System - ROS) Computer vision (image recognition, especially for indoor navigation) Hardware design (robot modules) Python development (Robot Operating System - ROS)  Please look at the list of repositories and active projects below, see the issues, and take something if you want. If you want to participate but do not know where to start, create an issue in this repository, and we will figure this out.\nAny volunteer participation will be appreciated!\n"},{"id":4,"href":"/doc/docs/systems/brain/","title":"Brain","section":"Systems and Components","content":"\nSoftware for Zakhar\u0026rsquo;s brain. The \u0026ldquo;soul\u0026rdquo; of the robot.\nThe part is represented by 3 sub-repositories:\n zakharos_core - set of ROS-packages with main programs (using it you can run the robot\u0026rsquo;s mind) zakhar_pycore - Python modules provides interaction with the hardware zakhar_service - repo for service, debugging and testing  Requirements #  Hardware #   Raspberry Pi \u0026gt;= 2 Gb RAM (or compatible platform) Compatible to the following I2C-devices:  an-dr/zakhar-face-module: Zakhar\u0026rsquo;s part which is responsible for facial expressions an-dr/zakhar_sensors: Sensors implementation for the Zakhar Project an-dr/zakhar_platform: Controlled from i2c and uart moving platform for zakhar    Software #   ROS1 noetic (how to install) Python 3.7 or newer Python packages from requirements.txt  Dev-Software #  For the development it is recommended to use VSCode with installed recomended extensions on the Host. As for the Target it is recommended to use Raspberry Pi 4 with 2Gb and more of RAM\nSchematic #  "},{"id":5,"href":"/doc/docs/systems/io/","title":"IO","section":"Systems and Components","content":"\nPart of the Zakhar project responsible for interaction\nConsists of two sub-repositories:\n Face Module Sensors  "},{"id":6,"href":"/doc/docs/systems/motion/wheeled-platform/","title":"Motors","section":"Motion","content":"\nMoving platform for Zakhar. Equipped by led indication and an MPU module (GY-91).\nSchematic #  Power:\nPlatform:\nStartup Sequence #   Blink by red and green leds Red led Motors test: forward, left, right Software initialization If no error detected - green led  "},{"id":7,"href":"/doc/docs/systems/","title":"Systems and Components","section":"Docs","content":"Systems and Components #  Zakhar consists of Units. Each Unit is a separate device with specific function.\nThe Units are designed to communicate with each other though a CAN-bus network. Zakhar has its own simple protocol ZakharCAN built on top of bare CANbus.\nEach Unit represents a ZakharCAN device with its unique DeviceID. Since it is possible to have two DeviceID on a single Unit we will use a term Node. Node is an ZakharCAN-compatible CANbus device with a unique DeviceID.\nTechnically all Nodes can send and receive data and commands, but only one (Brain) is developed to perform as the Main Node. Other Nodes can be considered as Secondary ones. The Main Node differs of Secondary Nodes by possibility of command sending. Secondary Nodes can only receive commands and send data.\nSystems #  All Units are split into Systems. A System is a group of Units serving a specific purpose. There are 4 Systems. Here is the full list and operating areas of each System:\n Brain System  Processing of data from Secondary Nodes Decision making Control   IO (In/Out) System  Collecting data from sensors (In) Interacting with the User: sound, video, light, etc. (Out)   Motion System  Physical interactions Movements   Diagnostics and Development (DnD) System  Collecting of technical information for diagnostics Technical support for the development - OTA controller updates, etc.    Units #  Here is the full list of Zakhar Units:\n Brain System  Brain Unit     IO (In/Out) System  Face Unit   Sensor Unit (Sensors)     Motion System  Wheeled Platform Unit     Diagnostics and Development (DnD) System  CAN Tool Unit     The main Node is the Brain Unit. Others are Secondary. Each Secondary periodically sends a special message so the Main Node knows that the Secondary is still connected to the network.\nAs it was told each Node has a unique DeviceID. List of the Node IDs is bellow. Since DeviceID uses a CANbus\u0026rsquo;s 11-bit ID field the Node IDs are written as CANbus IDs but with X on positions that can vary for the same Node. 0x1XX means that CAN messages with IDs 0x101, 0x10A, and 0x104 are considered as messages from the same node.\n   Node/Unit 11-bit ID     Brain 0x1XX   Wheeled Platform 0x2XX   Face 0x3XX   Sensors 0x4XX   CAN Tool 0x7XX    Message Content #  WIP\n"}]